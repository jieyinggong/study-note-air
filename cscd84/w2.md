
## constraint satification problem csp
- scheduling
- industrial process optimzation
- planning layorts for  


### components of csd 
-> variables -> scheduling
- time slots in the daily schedule
- courses that read a time slot
	- example: 
	- each course with different day and time  ->state is partial or complete assgnment of values to varialbe
	- csp variable have discrete/finite domains

### set of constraints
- conditions apply to one or more variables -> limit their possible values & constraint graph
	- unary -> one variable 
		- e.g. a48 can not be after 4 pm
	- binary -> 2 variables 
		- d84 -- a48 can not have same values

constraint graph -> show all variables all constraints that apply

example

search -> backtracking search -> dfs
initialize config to {}
recursive backtracking (config, set-of-vars, set-of-constraints)
- check if it is solved ->then success
- not solved
	- choose one un-assigned var
	- try each possible value in some order expand assignment with{} + var = new value recursively backtracking (assign,vars,constraint) <- if valid
		- if not success -> return failure -> also remove the assignment at previous level
complexity of BTS
- n variables and d domain size (d^N)

 speeding up bts
 
 1. keep track of possible assignment left for each variable backtrack whenever one set becomes {}
	 ->3 heuristics
	- choose variable with fewest remaining values first 
	- choose var with largest number of active constraints
	- choose the least constraining value -> less likely to fail


complexity headaches: O(d^N)
- tree structured csp -> O(Nd^2)


a). do a topological sort starting at some node
- 2 pass process -> from right to left 
- remove values in parent that make problem not satisficable

choose k variable s to give values to make tcsp
leaves a tcsp with n-k variables

iterative method for approx/partically solving csp
->start with initial random assignment to all variable
(probably bad)
loop:
- choose a variable
- choose a random new value for variable
- count number of broken constraint 
- keep if better than previous 
	- allow to choose bad.worse confis randomly with sample p

-> local search
- problem: reach local minimum

-> heuristics -> choose var with most broken constraints
- value -> that decreates broken constraints the most
